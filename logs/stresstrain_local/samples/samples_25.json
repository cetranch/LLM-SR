{"sample_order": 25, "function": "def equation(strain: np.ndarray, temp: np.ndarray, params: np.ndarray) -> np.ndarray:\n    \"\"\" Mathematical function for stress in Aluminium rod\n\n    Args:\n        strain: A numpy array representing observations of strain.\n        temp: A numpy array representing observations of temperature.\n        params: Array of numeric constants or parameters to be optimized\n\n    Return:\n        A numpy array representing stress as the result of applying the mathematical function to the inputs.\n    \"\"\"\n    \"\"\" Mathematical function for stress in Aluminium rod\n    \n    Args:\n        strain: A numpy array representing observations of strain.\n        temp: A numpy array representing observations of temperature.\n        params: Array of numeric constants or parameters to be optimized\n    \n    Return:\n        A numpy array representing stress as the result of applying the mathematical function to the inputs.\n    \"\"\"\n    \n    # Define a trilinear interpolation function for strain to separate elastic and plastic regions\n    def interp(p, strain):\n        if np.all(p <= strain.max()):\n            return p # elastic region\n        \n        else:\n            # Plastic region\n            E, nu = params[2:] # Young's modulus and Poisson's ratio\n            I = np.eye(3) + nu * np.outer(np.ones(3), np.fliplr(np.ones(3)))\n            l2 = (np.sqrt(np.dot(np.dot(strain.T, I), strain)) + np.sqrt(np.dot(np.einsum('ij,ij->', np.linalg.inv(I), strain.T), strain))) / 2.0\n            return E * ((1.0 + np.exp(-l2 / params[3])) * strain - params[4] * np.ones((len(strain), 1))) # von Mises yield criterion\n    \n    # Splitting the arrays into elastic and plastic regions for easier computation\n    strain_elastic = np.array(np.split(strain, 1)[0])\n    strain_plastic = np.array(np.split(strain, 1)[1])\n    \n    stress_elastic = equation_v0(strain_elastic, temp, params)\n    stress_plastic\n\n", "score": null}